                                               <<<<<<<<<<<<<<<<<<<<<<<<<<<PYTHON__MAIN_TOPICS>>>>>>>>>>>>>>>>>>>>>>>>>>>

‚ñ∂Ô∏èclass:- class is a collection of datamenbers and member functions.
Example1:-Constructor_method with class
class Laptop:
    def __init__(self, company, colour, cpu_ram):
        self.company = company
        self.colour = colour
        self.cpu_ram = cpu_ram
	def display(self):                 #this is optional
        return f"Laptop({self.company}, {self.colour}, {self.cpu_ram}GB RAM)"	

l = Laptop("hp", "white", 8)
print(l.colour)
print(l.cpu_ram)
print(l.company)                #output:---white,8,hp 

‚ñ∂Ô∏èExample2:-Normal class method
class Laptop:
    name="hp"
    colour="redd"
    model="HP"
    cpu_ram=20

    def display(self):
        print(self.name,self.colour,self.model,self.cpu_ram)
l=Laptop()
print(l.name)
print(l.display())

#output:-
hp
hp redd HP 20
None
=======================================================================================================================================================================
‚ñ∂Ô∏èobject:--object is an instance of a class it has its own state, behavior, and identity.
class Laptop:
    def __init__(self, company, colour, cpu_ram):
        self.company = company
        self.colour = colour
        self.cpu_ram = cpu_ram

l = Laptop("hp", "white", 8)
print(l.colour)
print(l.cpu_ram)
print(l.company)           #output:---white,8,hp
======================================================================
‚ñ∂Ô∏èEncapsulation:- Encapsulation protecting our data  is called encapsulation.ex:Hides internal details. Achieved using private variables.
Example:- "Encapsulation is like an office bag that keeps your laptop, mouse, and charger inside. You can't see or directly access each item ‚Äî they‚Äôre protected. You must open the bag (controlled access) to use them. Similarly, in OOP, 

‚ñ∂Ô∏èclass Person:
    def __init__(self, name, age):
        self.name = name            # Public attribute
        self.__age = age            # Private attribute (encapsulated)

    def get_age(self):              # Getter method to access private variable
        return self.__age

    def set_age(self, new_age):     # Setter method to update private variable
        if new_age > 0:
            self.__age = new_age
        else:
            print("Invalid age!")

# Creating a Person object
p1 = Person("Alice", 25)

# Accessing public and private data
print(p1.name)             # ‚úÖ Accessing public variable directly
print(p1.get_age())        # ‚úÖ Accessing private variable using getter method

# Updating private variable using setter method
p1.set_age(30)
print(p1.get_age())        # ‚úÖ Output: 30

# Trying to access private variable directly (will cause error)
# print(p1.__age)          ‚ùå Error: 'Person' object has no attribute '__age'

(or)

‚ñ∂Ô∏èclass Employee:
    def __init__(self, name, salary):
        self.name = name            # public variable
        self.__salary = salary      # private variable (encapsulated)

    def get_salary(self):           # public method to access private data
        return self.__salary

    def set_salary(self, amount):   # public method to modify private data
        if amount > 0:
            self.__salary = amount
        else:
            print("Invalid salary!")

# Create object
emp = Employee("John", 50000)

print(emp.name)              # ‚úÖ Accessible (public)
print(emp.get_salary())      # ‚úÖ Accessing private data via method

emp.set_salary(60000)        # ‚úÖ Modifying private data via method
print(emp.get_salary())      # Output: 60000

# print(emp.__salary)        ‚ùå This would cause an error (private)
============================================================================
‚ñ∂Ô∏èAbstraction:- Abstraction refers to the process of hiding.

ATM Machine (Abstraction):
You press a button to withdraw cash.
You don‚Äôt see how:
Your account is verified
Cash is counted
Logs are stored
You only see essential actions. All internal processing is hidden ‚Äî that‚Äôs abstraction.

‚ñ∂Ô∏èfrom abc import ABC, abstractmethod
class Bank(ABC):
    @abstractmethod
    def loan_approval(self):
        pass

class SBI(Bank):
    def loan_approval(self):
        return "SBI: Loan Approved"

class HDFC(Bank):
    def loan_approval(self):
        return "HDFC: Loan Approved"

b = HDFC()
print(b.loan_approval())  # Output: HDFC: Loan Approved
(or)

‚ñ∂Ô∏èfrom abc import ABC, abstractmethod
class Animal(ABC):  # Abstract base class
    @abstractmethod
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        return "Woof!"

class Cat(Animal):
    def sound(self):
        return "Meow"

# Using abstraction
a = Dog()
print(a.sound())          # Output: Woof!
=======================================================================================================================
‚ñ∂Ô∏èinheritance:-Inheritance : It is process of creating a new class from already existing class.
existing class is called as base class or super class and new class is called as derived class or sub class.

class Animal:  # ‚Üê parent/base/superclass
    def speak(self):
        return "Sound"

class Dog(Animal):  # ‚Üê child/derived/subclass
    def bark(self):
        return "Woof!"

d = Dog()         # Creating object of child class
print(d.speak())  # inherited from Animal
print(d.bark())   # defined in Dog
#output:-Woof!

         (or)
		 
class Animal:
    def speak(self):
        return "I make sound"

class Dog(Animal):
    def bark(self):
        return "Woof!"

d = Dog()
print(d.speak())  # Inherited

Output:
I make sound
=================================================================================================
‚ñ∂Ô∏èsingle inheritance:-Single inheritance enables a derived class to inherit properties from a single parent class,
thus enabling code reusability and the addition of new features to existing code.
(OR)
one child class inherits from parent class is called single inherits.

class Parent:
    def work(self):
        print("Parent is working.")

class Child(Parent):  # Inheriting from one parent only
    def play(self):
        print("Child is playing.")

c = Child()
c.work()  # Inherited from Parent
c.play()  # Defined in Child
Output:--
Parent is working.
Child is playing.
=================================================================================================
‚ñ∂Ô∏èmultiple inheritance:-When a class is derived from more than one base class it is called multiple Inheritance.
The derived class inherits all the features of the base case. Syntax: Class Base1: Body of the class Class Base2: 
Body of the class Class Derived(Base1, Base2): Body of the class.2
(OR)
A child class inherits from multiple parent classes is called multiple inheritance

class father:
    def skill(self):
        print('father: gardening')

class mother:
    def hobby(self):
        print('mother: painting')

class child(father, mother):
    def play(self):
        print('child: playing')

# These lines should be outside the class definition
c = child()
c.skill()
c.hobby()
c.play()

Output:--
father: gardening
mother: painting
child: playing
=================================================================================================
‚ñ∂Ô∏èmulti level inheritance:-In multilevel inheritance, features of the base class and the derived class are further inherited into the new derived class.
This is similar to a relationship representing a child and a grandfather.
(OR)
One class inherits from another, and then another class inherits from it (a chain).
(OR)
One class inherits from a class, which itself inherits from another class.

class grandfather:
  def house(self):
    print('grandfarher has a big house')
class parent(grandfather):
  def car(self):
    print('parents drives a car')

class child(parent):
  def bike(self):
    print('child rides a bike')

c=child()
c.house()
c.car()
c.bike()

Output:--
grandfarher has a big house
parents drives a car
child rides a bike
=================================================================================================
‚ñ∂Ô∏èhierarchical inheritance:-When more than one derived class are created from a single base this type of inheritance is called hierarchical inheritance.
In this program, we have a parent (base) class and two child (derived) classes.
(OR)
Multiple child classes inherit from the same parent class.

class Animal:
    def eat(self):
        print("Animal eats")

class Dog(Animal):
    def bark(self):
        print("Dog barks")

class Cat(Animal):
    def meow(self):
        print("Cat meows")

d = Dog()
d.eat()
d.bark()

c = Cat()
c.eat()
c.meow()

output:----
Animal eats
Dog barks
Animal eats
Cat meows
=================================================================================================
‚ñ∂Ô∏èHybrid Inheritance:A mix of multiple inheritance types (like multilevel + multiple).

class A:
    def feature1(self):
        print("Feature 1 from A")

class B(A):
    def feature2(self):
        print("Feature 2 from B")

class C:
    def feature3(self):
        print("Feature 3 from C")

class D(B, C):
    def feature4(self):
        print("Feature 4 from D")

d = D()
d.feature1()
d.feature2()
d.feature3()
d.feature4()

output:---
Feature 1 from A
Feature 2 from B
Feature 3 from C
Feature 4 from D
=================================================================================================
‚ñ∂Ô∏èmultipath inheritance or cyclic inheritance
=================================================================================================
‚ñ∂Ô∏èPolymorphism:-The"polymorphism" means "many forms", and in programming it refers to methods/functions/operators with the same name that can be executed on many objects or classes
‚ñ∂Ô∏èPolymorphism:---The"polymorphism" means "many forms",Same method name, different behavior depending on the object.

class Cat:
    def speak(self):
        return "Meow"

class Dog:
    def speak(self):
        return "Woof"

for pet in (Cat(), Dog()):
    print(pet.speak())  #Output: Meow,Woof
==================================================================================================
‚ñ∂Ô∏èMethod overriding in oops:---‚úÖ Child can override parent method.
The child class can override a method defined in the parent class by defining a method with the same name, parameters, and behavior structure.

*jst remember method overriding and inheritance little bit same.
	
class Animal:
  def speak(self):
    print('make sound')
class Dog(Animal):
  def speak(self):
    print('bow')
class Cat(Animal):
  def speak(self):
    print('meow')

a=Animal()
d=Dog()
c=Cat()
a.speak()
d.speak()
c.speak()

#output:-
make sound
bow
meow
=================================================================================================
‚ñ∂Ô∏èmethod overloading:----
class Greet:
    def say_hello(self, name=None):
        if name:
            print("Hello", name)
        else:
            print("Hello")

g = Greet()
g.say_hello()           # Output: Hello
g.say_hello("Alice")    # Output: Hello Alice

(or)

class Info:
    def show(self, name="User", age=None):
        if age:
            print(f"Name: {name}, Age: {age}")
        else:
            print(f"Name: {name}")

i = Info()
i.show()                # Output: Name: User
i.show("Tom")           # Output: Name: Tom
i.show("Tom", 25)       # Output: Name: Tom, Age: 25

(or)

class Calculator:
    def add(self, a, b=0):
        print("Sum is:", a + b)

c = Calculator()
c.add(5)          # Output: Sum is: 5
c.add(5, 3)       # Output: Sum is: 8
=========================================================================
DATATYPES:‚ñ∂Ô∏èLists in python
| Data Type | Syntax Example                     | Ordered? | Mutable? | Allows Duplicates? |
|-----------|------------------------------------|----------|----------|---------------------|
| `list`    | `["apple", "banana", "cherry"]`    | ‚úÖ Yes    | ‚úÖ Yes    | ‚úÖ Yes              |
| `tuple`   | `("apple", "banana", "cherry")`    | ‚úÖ Yes    | ‚ùå No     | ‚úÖ Yes              |
| `set`     | `{"apple", "banana", "cherry"}`    | ‚ùå No     | ‚úÖ Yes    | ‚ùå No               |
| `dict`    | `{"name": "John", "age": 25}`      | ‚úÖ Yes*   | ‚úÖ Yes    | ‚ùå No (keys only)   |
| `str`     | `"hello"`                          | ‚úÖ Yes    | ‚ùå No     | ‚úÖ Yes              |

üß† Quick Notes:
‚úÖ Use list when you need an ordered, changeable collection.
‚úÖ Use tuple when you need an ordered, unchangeable collection.
‚úÖ Use set when you need a unique, unordered collection.
‚úÖ Use dict for key-value pairs.

‚ñ∂Ô∏èWhat is a List?:-list is a collection of data and it is a mutable and ordered and we can change the values in list, list allow the dupicate values also lists are indicated by square brackets [].

‚ñ∂Ô∏èCreating a List: 
fruits = ["apple", "banana", "mango"]
print(fruits)             #output:  ["apple", "banana", "mango", "orange"]

‚ñ∂Ô∏èAccessing Items:
fruits = ["apple", "banana", "cherry"] 
print(fruits[0])          # Output: [apple]

‚ñ∂Ô∏èAdding Items:
fruits = ["apple", "banana", "cherry"]
fruits.append("orange")  
print(fruits)             # Output: ["apple", "banana", "mango", "orange"]

‚ñ∂Ô∏èRemoving Items:
fruits = ["apple", "banana", "cherry"] 
fruits.remove("banana")   
print(fruits)             # Output: ["apple", "mango", "orange"]

‚ñ∂Ô∏èRemove Specified Index:-The pop() method removes the specified index, Remove the second item:
fruits = ["apple", "banana", "cherry"]
fruits.pop(1)
print(fruits)             #output:['apple', 'cherry']

‚ñ∂Ô∏èRemove the last item:-If you do not specify the index, the pop() method removes the last item.
fruits = ["apple", "banana", "cherry"]
fruits.pop()
print(fruits)             #output:['apple', 'banana']


‚ñ∂Ô∏èThe del keyword also removes the specified index, Remove the first item: 
fruits = ["apple", "banana", "cherry"]
del fruits[0]
print(fruits)             #output:['banana', 'cherry']

‚ñ∂Ô∏èThe del keyword can also delete the list completely, Delete the entire list:
fruits = ["apple", "banana", "cherry"]
del fruits                #output:NameError:#this will cause an error because you have succsesfully deleted "thislist".

‚ñ∂Ô∏èClear the List:--Clear the list content:
fruits = ["apple", "banana", "cherry"]
fruits.clear()
print(fruits)              #output:show like this symbol []

‚ñ∂Ô∏èChange Item Value:---To change the value of a specific item, refer to the index number: Change the second item:
fruits = ["apple", "banana", "cherry"]
fruits[1] = "blackcurrant" 
print(fruits)              #output:['apple', 'blackcurrant', 'cherry']

‚ñ∂Ô∏èInsert Items:---The insert() method inserts an item at the specified index:
fruits = ["apple", "banana", "cherry"]
fruits.insert(2, "watermelon")
print(fruits)             #output:['apple', 'banana', 'watermelon', 'cherry']

‚ñ∂Ô∏èAppend Items:--To add an item to the end of the list, use the append() method:
fruits = ["apple", "banana", "cherry"]
fruits.append("orange")
print(fruits)             #output:['apple', 'banana', 'cherry', 'orange']

‚ñ∂Ô∏èExtend List:--To append elements from another list to the current list, use the extend() method.
fruits = ["apple", "banana", "cherry"]
my_fruits = ["mango", "pineapple", "papaya"]
fruits.extend(my_fruits)
print(fruits)             #output:['apple', 'banana', 'cherry', 'mango', 'pineapple', 'papaya']

‚ñ∂Ô∏èPython - Loop Lists:--You can loop through the list items by using a for loop, Print all items in the list, one by one:
fruits = ["apple", "banana", "cherry"]
for x in fruits:
  print(x)                #output:apple,banana,cherry

‚ñ∂Ô∏èPython - Sort Lists:--- Sort List Alphanumerically, List objects have a sort() method that will sort the list alphanumerically, ascending, by default:Sort the list alphabetically:
fruits = ["orange", "mango", "kiwi", "pineapple", "banana"]
fruits.sort()
print(fruits)              #output:['banana', 'kiwi', 'mango', 'orange', 'pineapple']

‚ñ∂Ô∏èSort Descending:---To sort descending, use the keyword argument reverse = True:
Sort the list descending:
fruits = ["orange", "mango", "kiwi", "pineapple", "banana"]
fruits.sort(reverse = True)
print(fruits)               #output:['pineapple', 'orange', 'mango', 'kiwi', 'banana']

‚ñ∂Ô∏èSort the list numerically with ascending:
fruits = [100, 50, 65, 82, 23]
fruits.sort()
print(fruits)               #output:[23, 50, 65, 82, 100]

‚ñ∂Ô∏èSort the list descending:
fruits = [100, 50, 65, 82, 23]
fruits.sort(reverse = True)
print(fruits)               #output:[100, 82, 65, 50, 23]

‚ñ∂Ô∏èUse the copy() method:-You can use the built-in List method copy() to copy a list.
Make a copy of a list with the copy() method:
fruits = ["apple", "banana", "cherry"]
mylist =fruits.copy()
print(mylist)               #output:['apple', 'banana', 'cherry']

‚ñ∂Ô∏èConvert list to tuple:df
fruits = ["apple", "banana", "cherry"]
x = tuple(fruits)
print(x)       #output: ['apple', 'banana', 'cherry']
========================================================================
TUPLE:-tuple is a collection of data and it is a immutable and ordered and we can't the change values, tuples are indicated by the paranthesis ().

‚ñ∂Ô∏èCreate a Tuple:
fruits = ("apple", "banana", "cherry")
print(fruits)             #output: ('apple', 'banana', 'cherry')

‚ñ∂Ô∏èAccess Tuple Items:-You can access tuple items by referring to the index number, inside square brackets: Print the second item in the tuple:
fruits = ("apple", "banana", "cherry")
print(fruits[1])          #output: banana

‚ñ∂Ô∏èNegative Indexing:-Negative indexing means start from the end, -1 refers to the last item, -2 refers to the second last item etc. Print the last item of the tuple:
fruits = ("apple", "banana", "cherry")
print(fruits[-1])         #output: cherry

‚ñ∂Ô∏èRange of Indexes:--Return the third, fourth, and fifth item:
fruits  = ("apple", "banana", "cherry", "orange", "kiwi", "melon", "mango")
print(fruits[2:5])        #output:('cherry', 'orange', 'kiwi')         #This will return the items from position 2 to 5.#and note that the item in position 5 is NOT included

‚ñ∂Ô∏èCheck if Item Exists:--To determine if a specified item is present in a tuple use the in keyword: Check if "apple" is present in the tuple:
fruits = ("apple", "banana", "cherry")
if "apple" in fruits:
  print("Yes, 'apple' is in the fruits tuple")    #output:Yes, 'apple' is in the fruits tuple
  
‚ñ∂Ô∏èChange Tuple Values:--Once a tuple is created, you cannot change its values. Tuples are unchangeable, or immutable as it also is called.
But there is a workaround. You can convert the tuple into a list, change the list, and convert the list back into a tuple.
Convert the tuple into a list to be able to change it:

fruits = ("apple", "banana", "cherry")
y = list(fruits)
y[1] = "kiwi"
fruits = tuple(y)
print(fruits)             #output: ("apple", "kiwi", "cherry")

‚ñ∂Ô∏èConvert tuple to list:
fruits =("apple", "banana", "cherry")
x=list(fruits)
print(x)       #output: ['apple', 'banana', 'cherry']

‚ñ∂Ô∏èAdd Items:--Since tuples are immutable, they do not have a built-in append() method, but there are other ways to add items to a tuple.
1. Convert into a list: Just like the workaround for changing a tuple, you can convert it into a list, add your item(s), and convert it back into a tuple.
Convert the tuple into a list, add "orange", and convert it back into a tuple:

fruits = ("apple", "banana", "cherry")
y = list(fruits)
y.append("orange")
fruits = tuple(y)
print(fruits)            #output:  ('apple', 'banana', 'cherry', 'orange')

‚ñ∂Ô∏èAdd Items to a tuple ia anothe way:--Create a new tuple with the value "orange", and add that tuple:   ‚ñ∂Ô∏è2nd way process to add items.
fruits = ("apple", "banana", "cherry")
y = ("orange",)
fruits += y          
print(fruits)            #output: ('apple', 'banana', 'cherry', 'orange')

‚ñ∂Ô∏èRemove Items:-Tuples are unchangeable, so you cannot remove items from it, but you can use the same workaround as we used for changing and adding tuple items:
Convert the tuple into a list, remove "apple", and convert it back into a tuple: Note: You cannot remove items in a tuple.
fruits = ("apple", "banana", "cherry")
y = list(fruits)
y.remove("apple")
fruits = tuple(y)
print(fruits)            #output: ('banana', 'cherry')

‚ñ∂Ô∏èyou can delete the tuple completely:The del keyword can delete the tuple completely:
fruits = ("apple", "banana", "cherry")
del fruits
print(fruits) #this will raise an error because the tuple no longer exists

‚ñ∂Ô∏èUnpacking a Tuple topic:-????

‚ñ∂Ô∏èPython Tuple count() Method
Return the number of times the value 5 appears in the tuple:
fruits = (1, 3, 7, 8, 7, 5, 4, 6, 8, 5)
x = fruits.count(5)
print(x)                 #output: 2     
  
‚ñ∂Ô∏èTuple Length:--To determine how many items a tuple has, use the len() function:Print the number of items in the tuple:
fruits = ("apple", "banana", "cherry")
print(len(fruits))        #output: 3   

‚ñ∂Ô∏èCreate Tuple With One Item:-To create a tuple with only one item, you have to add a comma after the item, otherwise Python will not recognize it as a tuple.
One item tuple, remember the comma:
fruits = ("apple",)
print(type(fruits))       #output: <class 'tuple'>

#NOT a tuple
thistuple = ("apple")
print(type(thistuple))    #output: <class 'str'>

‚ñ∂Ô∏èAllow Duplicates:--Tuples allow duplicate values:
fruits = ("apple", "banana", "cherry", "apple", "cherry")
print(fruits)             #output: ('apple', 'banana', 'cherry', 'apple', 'cherry')
===========================================================================================
SETS:-A set is a collection of heterogeneous elememts,it does n't allow duplicate values and it mainly used to remove duplicate elements in another data structure.set items are unordered, changeable*, and unindexed.

‚ñ∂Ô∏èCreate a Set
fruits = {"apple", "banana", "cherry"}
print(fruits)             # Output: {'cherry', 'apple', 'banana'}

‚ñ∂Ô∏èAdd an item
fruits = {"apple", "banana"}
fruits.add("cherry")
print(fruits)             # Output: {'apple', 'banana', 'cherry'}

‚ñ∂Ô∏èAdd multiple items (update)
fruits = {"apple", "banana"}
fruits.update(["cherry", "mango"])
print(fruits)             # Output: {'apple', 'banana', 'cherry', 'mango'}

‚ñ∂Ô∏èRemove an item
fruits = {"apple", "banana", "cherry"}
fruits.remove("banana")
print(fruits)             # Output: {'apple', 'cherry'}

‚ñ∂Ô∏èDiscard an item (no error if missing)
fruits = {"apple", "banana"}
fruits.discard("mango")  
print(fruits)             # no error

‚ñ∂Ô∏èPop an item (removes random item)
fruits = {"apple", "banana", "cherry"}
item = fruits.pop()
print(item)
print(fruits)

# Output:
apple
{'cherry', 'banana'}

‚ñ∂Ô∏èClear a set
fruits = {"apple", "banana"}
fruits.clear()
print(fruits)            #Output: set()

‚ñ∂Ô∏èDelete a set
fruits = {"apple", "banana"}
del fruits               # print(fruits) ‚Üí Error: not defined

‚ñ∂Ô∏èCopy a set
a = {1, 2, 3}
b = a.copy()
print(b)                 #Output:  {1, 2, 3}

‚ñ∂Ô∏èRemoving Duplicates from strings:
fruits = ["apple", "banana", "apple", "cherry", "banana"]
unique_items = set(fruits)
print(unique_items)      #Output:  {'cherry', 'apple', 'banana'}

‚ñ∂Ô∏èRemoving Duplicates from a List:
nums = [1, 2, 2, 3, 4, 4, 5]
unique = list(set(nums))
print(unique)            #Output:  [1, 2, 3, 4, 5]

‚ñ∂Ô∏èBut heads up ‚Äî it doesn‚Äôt preserve the order.
Preserving Order While Removing Duplicates:
nums = [1, 2, 2, 3, 1, 4]
seen = set()
unique = []
for num in nums:
    if num not in seen:
        unique.append(num)
        seen.add(num)
		
		(or)
		
‚ñ∂Ô∏ènums = [1, 2, 2, 3, 1, 4]
unique = list(dict.fromkeys(nums))
print(unique)            #Output:  [1, 2, 3, 4]

========================================================================
‚ñ∂Ô∏èWhat is a Dictionary? 
 A dictionary is a collection of key-value pairs, The dictionary keys must be unique. The dictionary value may be of any type,
 A dictionary is an unordered and mutable, Dictionaries are indicated by curly braces {}.

‚ñ∂Ô∏èCreating a Dictionary: 
person = {"name": "Alice", "age": 25,  "city": "New York"}
    
‚ñ∂Ô∏èAccessing Values :
person = {"name": "Alice", "age": 25,  "city": "New York"}
print(person["name"])     # Output: Alice
print(person.get("age"))  # Output: 25      #Using .get() is safer because it won‚Äôt crash if the key doesn‚Äôt exist.

‚ñ∂Ô∏èGet Keys:----The keys() method will return a list of all the keys in the dictionary, Get a list of the keys:
person = {"name": "Alice", "age": 25,  "city": "New York"}
print(person.keys())
(or)
x = person.keys()
print(x)

‚ñ∂Ô∏èGet Values:--The values() method will return a list of all the values in the dictionary, Get a list of the values:
person = {"name": "Alice", "age": 25,  "city": "New York"}
print(person.values())
(or)
x = person.values()
print(x)

‚ñ∂Ô∏èGet Items:--The items() method will return each item in a dictionary, as tuples in a list, Get a list of the key:value pairs
person = {"name": "Alice", "age": 25,  "city": "New York"}
print(person.items())
(or)
x = person.items()
print(x)


‚ñ∂Ô∏èCheck if Key Exists:-To determine if a specified key is present in a dictionary use the in keyword, Check if "model" is present in the dictionary:
person = {"brand": "Ford", "model": "Mustang", "year": 1964}
if "model" in thisdict:
  print("Yes, 'model' is one of the keys in the thisdict dictionary")  #output: Yes, 'model' is one of the keys in the thisdict dictionary

‚ñ∂Ô∏èAdding items
person = {"name": "Alice", "age": 25,  "city": "New York"}
person["email"] = "alice@example.com"  # Add new key
print(person)

‚ñ∂Ô∏èUpdating Items:
person = {"name": "Alice", "age": 25,  "city": "New York"}
person["age"] = 26                     # Update value
print(person)

‚ñ∂Ô∏èAdding New Key-Value Pair:
person = {"name": "Alice", "age": 25,  "city": "New York"}
person["city"] = "Delhi"
print(person)

‚ñ∂Ô∏èChanging Value:
person = {"name": "Alice", "age": 25,  "city": "New York"}
person["age"] = 30
print(person)

‚ñ∂Ô∏èDeleting Items: 
person = {"name": "Alice", "age": 25,  "city": "New York"}
del person["city"]
print(person)

‚ñ∂Ô∏èLooping through a Dictionary: 
for key, value in person.items():
    print(key, ":", value)

‚ñ∂Ô∏è Why Use Dictionaries? 
- Fast access via keys
- Ideal for storing structured data (like a JSON object)
- Very flexible in combining with loops and functions


‚ñ∂Ô∏èTrick :
- Use lists when order matters.
- Use dictionaries when you want to label your data.

‚ñ∂Ô∏èdict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}
print(dict.values())
(or)
x=dict.values()
print(x)       #output: dict_values(['Zara', 7, 'First'])

‚ñ∂Ô∏èUsing .get() to avoid KeyErrors: 
If a key doesn't exist, .get() won't crash your code ‚Äî you can return a default value instead.
print(student.get("gender", "Not specified"))


‚ñ∂Ô∏èLooping through a Dictionary: 
student = {"name": "Alice", "age": 25}
for key, value in student.items():
    print(f"{key}: {value}")  
#output:
name: Alice
age: 25


‚ñ∂Ô∏èDictionary Comprehension :
squares = {x: x*x for x in range(5)}
print(squares) #output: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

‚ñ∂Ô∏èMerging Two Dictionaries
a = {"x": 1}
b = {"y": 2}
merged = a | b
print(merged)  #output: {'x': 1, 'y': 2}

‚ñ∂Ô∏èstudent = {"name": "Alice", "age": 25}  #Always use .get() when you‚Äôre not sure if a key exists ‚Äî it‚Äôs cleaner and safer.
print(student.get("grade", "N/A"))  #output: N/A

Explanation:----------
.get("grade", "N/A") tries to get the value for the key "grade".
If "grade" does not exist, it returns "N/A" instead of raising an error.
This is safer than directly accessing student["grade"], which would cause a KeyError.
=========================================================================
STRING:-A string is a collection (or sequence) of characters.string is a immutable and we can't the changed values,after they are created.strings are indicated by the quotes.

‚ñ∂Ô∏è Common String Operations in Python:
| Operation             | Description                              | Example & Output                          |
| --------------------- | ---------------------------------------- | ----------------------------------------- |
| `len()`               | Get length of string                     | `len("hello")` ‚Üí `5`                      |
| `+` (concatenation)   | Join strings                             | `"Hello" + " World"` ‚Üí `"Hello World"`    |
| `*` (repeat)          | Repeat string                            | `"Hi" * 3` ‚Üí `"HiHiHi"`                   |
| `str.upper()`         | Convert to uppercase                     | `"hello".upper()` ‚Üí `"HELLO"`             |
| `str.lower()`         | Convert to lowercase                     | `"HELLO".lower()` ‚Üí `"hello"`             |
| `str.strip()`         | Remove leading/trailing spaces           | `" hello ".strip()` ‚Üí `"hello"`           |
| `str.replace(a, b)`   | Replace part of string                   | `"apple".replace("a", "b")` ‚Üí `"bpple"`   |
| `str.split()`         | Split into list by spaces (or character) | `"a b c".split()` ‚Üí `['a', 'b', 'c']`     |
| `str.find(sub)`       | Find position of substring               | `"hello".find("e")` ‚Üí `1`                 |
| `str.count(sub)`      | Count occurrences of substring           | `"banana".count("a")` ‚Üí `3`               |
| `str.startswith(sub)` | Check if string starts with sub          | `"hello".startswith("he")` ‚Üí `True`       |
| `str.endswith(sub)`   | Check if string ends with sub            | `"hello".endswith("lo")` ‚Üí `True`         |
| `str.isalpha()`       | Check if all characters are letters      | `"abc".isalpha()` ‚Üí `True`                |
| `str.isdigit()`       | Check if all characters are digits       | `"123".isdigit()` ‚Üí `True`                |
| `str.isalnum()`       | Check if all characters are alphanumeric | `"abc123".isalnum()` ‚Üí `True`             |
| `str.title()`         | Capitalize each word                     | `"hello world".title()` ‚Üí `"Hello World"` |
| `str.capitalize()`    | Capitalize first letter                  | `"hello".capitalize()` ‚Üí `"Hello"`        |

‚ñ∂Ô∏èCreating Strings:
name = '''Alice'''
greeting = "Hello"
age  = '27'
print(name, greeting, age) #output: Alice Hello

‚ñ∂Ô∏èString Methods: 
text = " hello world "
print(text.strip())   # Removes whitespace ‚Üí 'hello world'  
print(text.upper())   # ‚Üí ' HELLO WORLD '  
print(text.lower())   # ‚Üí ' hello world '  
print(text.title())   # ‚Üí ' Hello World '  
print(text.replace(" ", "-")) # ‚Üí'-hello-world-'

‚ñ∂Ô∏èString Slicing: 
text = "Python"
print(text[0:4])   # ‚Üí 'Pyth'
print(text[-1])    # ‚Üí 'n'

‚ñ∂Ô∏èSlicing Strings
b = "Hello, World!"
print(b[2:5])      #output: llo

‚ñ∂Ô∏èSlice From the Start:--Get the characters from the start to position 5 (not included):
b = "Hello, World!"
print(b[:5])       #output: Hello

‚ñ∂Ô∏èSlice To the End:---Get the characters from position 2, and all the way to the end:
b = "Hello, World!"
print(b[2:])       #output: llo, World!

‚ñ∂Ô∏èNegative Indexing:--Get the characters:
From: "o" in "World!" (position -5)
To, but not included: "d" in "World!" (position -2):
b = "Hello, World!"
print(b[-5:-2])    #output:  orl

‚ñ∂Ô∏èModify Strings:--The upper() method returns the string in upper case:
a = "Hello, World!"
print(a.upper())   #output: HELLO, WORLD!

‚ñ∂Ô∏èLower Case:--The lower() method returns the string in lower case:
a = "Hello, World!"
print(a.lower())   #output: hello, world!

‚ñ∂Ô∏èRemove Whitespace:--The strip() method removes any whitespace from the beginning or the end:
a = " Hello, World! "
print(a.strip())   #output: Hello, World!

‚ñ∂Ô∏èReplace String:---The replace() method replaces a string with another string:
a = "Hello, World!"
print(a.replace("H", "J"))   #output: Jello, World!

‚ñ∂Ô∏èSplit String:--The split() method splits the string into substrings if it finds instances of the separator:
a = "Hello, World!"
print(a.split(",")) #output: ['Hello', ' World!']

‚ñ∂Ô∏èString Concatenation:-Merge variable a with variable b into variable c:
a = "Hello"
b = "World"
c = a + b
print(c)            #output:  HelloWorld

‚ñ∂Ô∏èF-Strings
age = 36
txt = f"My name is John, I am {age}"
print(txt)          #output:  My name is John, I am 36

‚ñ∂Ô∏èString Formatting: 
name = "Alice"
age = 25
print(f"My name is {name} and I'm {age} years old.")  #output:  My name is Alice and I'm 25 years old.

‚ñ∂Ô∏èEx:===What will be the output of the following code?
text = "  Python Is Fun  "
result = text.strip().lower().replace(" ", "-")
print(result)        #output: python-is-fun
Explanation above syntax:---
strip() removes the spaces at the beginning and end ‚Üí 'Python Is Fun'
lower() converts to lowercase ‚Üí 'python is fun' 
replace(" ", "-") replaces spaces with dashes ‚Üí 'python-is-fun'
===============================================================================================================================================================
‚ñ∂Ô∏èPython For Loops:---------

A for loop is used for iterating over a sequence (that is either a list, a tuple, a dictionary, a set, or a string).
This is less like the for keyword in other programming languages, and works more like an iterator method as found in other object-orientated programming languages.

With the for loop we can execute a set of statements, once for each item in a list, tuple, set etc.
fruits = ["apple", "banana", "cherry"]
for x in fruits:
  print(x)
  
Output:-
  
apple
banana
cherry

‚ñ∂Ô∏èThe break Statement
With the break statement we can stop the loop before it has looped through all the items:

fruits = ["apple", "banana", "cherry"]
for x in fruits:
  print(x)
  if x == "banana":
    break
Output:-
Apple
banana

‚ñ∂Ô∏èThe continue Statement
With the continue statement we can stop the current iteration of the loop, and continue with the next:

Example:---Do not print banana:  

fruits = ["apple", "banana", "cherry"]
for x in fruits:
  if x == "banana":
    continue
  print(x)
  
output:-
apple
cherry
===================================================
l=[1,2,3,4,5]
for x in l:
    print(x)  O/P:--1,2,3,4,5
===================================================
l=[1,2,3,4,5]
for x in l:
    if x==2:               #Exit the loop when x is "2", but this time the break comes before the print:
        break
    print(x)     O/P:--1
===================================================
#With the continue statement we can stop the current iteration of the loop, and continue with the next:
l=[1,2,3,4,5]   
for x in l:
    if x==2:               # Skip the iteration when x equals 2
        continue
    print(x)  O/P:--1,3,4,5
===============================
#With the break statement we can stop the loop before it has looped through all the items:
l=[1,2,3,4,5]
for x in l:
    print(x)
    if x==3:
        break O/P:--1,2,3   
===============================
l=[1,2,3,4,5]
for x in l:
    if x==5:
        print(x) O/P:--5
========================================================================
‚ñ∂Ô∏èWhile loop:----
while count <= 5: ‚Äî What does this mean?
This is the loop condition. It controls whether the loop keeps running or stops.

# Example 1: Print numbers 1 to 5
count = 1
while count <= 5:
    print("Number is:", count)
    count += 1
#output:-
Number is: 1
Number is: 2
Number is: 3
Number is: 4
Number is: 5
=============================================================================
# Example 2: Print even numbers from 2 to 10
num = 2
while num <= 10:
    print(num)
    num += 2
#output:--2,4,6,8,10
=============================================================================
# Example 3: Countdown from 5 to 1
count = 5
while count >= 1:
    print(count)
    count -= 1
#output:--5,4,3,2,1
=============================================================================
‚úÖ Simple translation:
"As long as count is less than or equal to 5, keep doing the loop."

Let‚Äôs say count = 3:

count <= 5 becomes 3 <= 5, which is True ‚Üí ‚úÖ loop runs

If count = 6: 6 <= 5 is False ‚Üí ‚ùå loop stops

üî¢ Real-life example:
Imagine you want to take 5 steps forward.

You might say:

‚ÄúWhile I haven‚Äôt taken more than 5 steps, keep walking.‚Äù

Each time you take a step, you add 1 to your step count. When your count reaches 6, you stop ‚Äî because you‚Äôve already taken 5 steps.
========================================================================
TOPIC NAMES IN FUNCTIONS:-------
‚ñ∂Ô∏èWHAT IS A FUNCTION
‚ñ∂Ô∏èCREATING FUNCTION
‚ñ∂Ô∏èCALLING A FUNCTION
‚ñ∂Ô∏èARGUMENTS
‚ñ∂Ô∏èNUMBER OF ARGUMENTS
‚ñ∂Ô∏èARBITRARY ARGUMENTS, *ARGS
‚ñ∂Ô∏èKEYWORD ARGUMENTS
‚ñ∂Ô∏èARBITRARY KEYWORD ARGUMENTS **KWARGS
‚ñ∂Ô∏èDEFAULT PARAMETER VALUE
‚ñ∂Ô∏èPASSING A LIST AS AN ARGUMENTS
‚ñ∂Ô∏èRETURN VALUES
++++++++++++++++++++++++++++++++++++++++++
‚ñ∂Ô∏èWHAT IS A FUNCTION:--"A function is a reusable block of code which only runs when it is called."

‚ñ∂Ô∏èCREATING A FUNCTION:-+++++++++++++++++++++++++++++++++++++++

In Python a function is defined using the def keyword:

Example:-
def my_function():
  print("Hello from a function")
  
‚ñ∂Ô∏èCALLING A FUNCTION:-++++++++++++++++++++++++++++++++++++++++

To call a function, use the function name followed by parenthesis:

Example:-

def my_function():
  print("Hello from a function")

my_function()
‚ñ∂Ô∏èARGUMENTS:-+++++++++++++++++++++++++++++++++++++++++++++++++
Information can be passed into functions as arguments.
Arguments are specified after the function name, inside the parentheses. You can add as many arguments as you want, just separate them with a comma.
The following example has a function with one argument (fname). When the function is called, we pass along a first name, which is used inside the function to print the full name:
Example:-

def my_function(fname):
  print(fname + " Refsnes")

my_function("Emil")
my_function("Tobias")
my_function("Linus")

OUTPUT:-
Emil Refsnes
Tobias Refsnes
Linus Refsnes

‚ñ∂***Function Call:--- how to called function Explanation here

my_function("Emil")    #Here‚Äôs what happens when Python sees this:

Step-by-step:
You call the function and pass in "Emil" as the argument.
Python assigns this value to the parameter:------  #fname = "Emil"

Now the function‚Äôs line becomes:----------#print("Emil" + " Refsnes")
Python concatenates the two strings:-----------"Emil Refsnes"

It prints:----Emil Refsnes

‚ñ∂Ô∏èNUMBER OF ARGUMENTS:-+++++++++++++++++++++++++++++++++++++++

By default, a function must be called with the correct number of arguments. Meaning that if your function expects 2 arguments, you have to call the function with 2 arguments, not more, and not less.

Example:-

This function expects 2 arguments, and gets 2 arguments:

def my_function(fname, lname):
  print(fname + " " + lname)

my_function("Emil", "Refsnes")

OUTPUT:-
Emil Refsnes
===================================================================================
‚ñ∂Ô∏èARBITRARY ARGUMENTS, *ARGS:-++++++++++++++++++++++++++++++++

If you do not know how many arguments that will be passed into your function, add a * before the parameter name in the function definition.

This way the function will receive a tuple of arguments, and can access the items accordingly:

Example:----If the number of arguments is unknown, add a * before the parameter name:

def my_function(*kids):
  print("The youngest child is " + kids[2])
my_function("Emil", "Tobias", "Linus")

output:---The youngest child is Linus
====================================================================================
‚ñ∂Ô∏èARBITRARY KEYWORD ARGUMENTS, **KWARGS:-+++++++++++++++++++++

If you do not know how many keyword arguments that will be passed into your function, add two asterisk: ** before the parameter name in the function definition.
This way the function will receive a dictionary of arguments, and can access the items accordingly:
Example:-------

If the number of keyword arguments is unknown, add a double ** before the parameter name:

def my_function(**a):
    print(a)
my_function(name = "asreddy", age = 25)
 
          (or)
def my_function(**kid):
  print("His last name is " + kid["lname"])
my_function(fname = "Tobias", lname = "Refsnes")   #output:------His last name is Refsnes

‚úÖ Another Similar Example:

def my_function(**student):
    print("The first name is " + student['fname'])
my_function(fname='Alice', lname='Walker')         #output:---The first name is Alice
==========================================================================================
‚ñ∂Ô∏èKeyword Arguments:-------------------------

You can also send arguments with the key = value syntax.
This way the order of the arguments does not matter.

Example
def my_function(child3, child2, child1):
  print("The youngest child is " + child3)

my_function(child1 = "Emil", child2 = "Tobias", child3 = "Linus")

output:-------The youngest child is Linus
==========================================================================================
‚ñ∂Ô∏èDAFAULT PARAMETERS VALUE:-++++++++++++++++++++++++++++++++++

The following example shows how to use a default parameter value.
If we call the function without argument, it uses the default value:

Example:-
def my_function(country = "Norway"):
  print("I am from " + country)

my_function("Sweden")
my_function("India")
my_function()
my_function("Brazil")

interview question:-----What is a default parameter?
A default parameter is a value that a function uses if no argument is provided.
‚ñ∂Ô∏èPASSING A LIST AS AN  ARGUMENTS:-++++++++++++++++++++++++++++++
You can send any data types of argument to a function (string, number, list, dictionary etc.), and it will be treated as the same data type inside the function.
E.g. if you send a List as an argument, it will still be a List when it reaches the function:

Example:-

def my_function(food):
  for x in food:
    print(x)

fruits = ["apple", "banana", "cherry"]

my_function(fruits)
‚ñ∂Ô∏èRETURN VALUES:-++++++++++++++++++++++++++++++++++++++++++++++
To let a function return a value, use the return statement:

Example:-def my_function(x):
             return 5 * x
print(my_function(3))    #Output:15
print(my_function(5))    #Output:25
print(my_function(9))    #Output:45
=============================================================================================================================================
‚ñ∂Ô∏èITERATOR:An iterator is an object in Python that allows traversing (iterating) through a sequence of elements, and 
it will print one by one value  using the __next__() method.
iterator consists of 2 methods one is iter(), another one is next()
iter():--this methods creates an iterator from the list.
next():--this method returns each element one by one.

EX:---
l = [1, 2, 3, 4, 5]
it = iter(l)  # Creates an iterator object from the list
print(next(it)) o/p:-1 # returns each element one by one.
print(next(it)) o/p:-2 # here aslo same process.

‚úÖ 2. Iterator with a For Loop:-----

EX:---
names = ["Alice", "Bob", "Charlie"]
for name in names:
    print(name)   
O/P:--
Alice
Bob
Charlie


EX:-3
l=[1,2,3,4,5]
for x in l:
    print (x) #O/P:-1,2,,4,5
==============================================
4. Skip value 3 using continue

l = [1, 2, 3, 4, 5]
for x in l:
    if x == 3:
        continue                            # Skip the iteration when x equals 3
    print(x) O/p:---1,2,4,5

=============================================
3. Stop printing when value is 4

l = [1, 2, 3, 4, 5]
for x in l:
    if x == 4:                              #Exit the loop when x is "4", but this time the break comes before the print:
        break
    print(x) O/P:--1,2,3
=============================================
1. Print only the first value in the loop:

l = [1, 2, 3, 4, 5]
for x in l:
    print(x)
    break    O/P:---1
=============================================
 2. Print a specific value (e.g., only the number 3):

l = [1, 2, 3, 4, 5]
for x in l:
    if x == 3:
        print(x)  O/P:---3
===============================================================================================================================================
‚ñ∂Ô∏èGENARATOR:generators are like functions which contain yield keyword.
Want Generator Behavior?
If you want to print multiple values, use yield.

EX:-
def my_gen():
    for i in range(10):
        yield i
result=my_gen()
print(next(result))
print(next(result)) o/p:---0,1
====================================================================
both are differences conditions can we observe:--------------------

def my_gen():
    for i in range(10):
        return i
result=my_gen()
print(result)      
print(result)     o/p:-----0,0 
====================================================================
1. First Example (Using next() manually):

def my_gen():
    for i in range(10):
        yield i

result = my_gen()
for i in range(10):
    print(next(result))  o/p:----0,1,2,3,4,5,6,7,8,9
==========================================================
2. Second Example (Using for loop directly):

def numbers():
    for i in range(5):
        yield i

for num in numbers():
    print(num) o/p:---0,1,2,3,4
==============================================================================================================================================
‚ñ∂Ô∏èDECORATOR:-"A decorator is a function that modifies the behavior of another function ‚Äî without changing the original function's code.
or
A decorator in Python is a way to add extra behavior to a function without changing its code.
EX:-----
def my_decorator(func):
    def modified():
        print('Good Morning BOSS!')
        func()
        print('bye!')
    return modified

@my_decorator    
def start():
    print('hello world')

start()
===============================================================================================
‚úÖ What Is a Lambda Function?
A lambda is an anonymous function (no name) written in one line function defined using the lambda keyword.
It's commonly used for short, simple operations, especially where a full def function would be unnecessarily verbose.

These are  Using lambda Functions:--------------

Syntax:---lambda arguments: expression

(1)Square a number

square = lambda x: x**2  
print(square(4))  # Output: 16

(2)Double a number

double = lambda x: x * 2
print(double(5))  # Output: 10

(3)Add two numbers

add = lambda a, b: a + b
print(add(3, 4))  # Output: 7
===============================================================================================================================================
‚ñ∂Ô∏èWhat is the map() function in Python?
map() applies a function to each item in an iterable (like a list) and returns a new iterable with the transformed results.

program:---
numbers=[1,2,3,4,5]
sqrs=list(map(lambda x:x*x, numbers))
print(sqrs)   #output will give:--[1,4,9,16,25]

Use map() + lambda to Get Cubes of Numbers:-----------------  

nums = [1, 2, 3, 4, 5]
cubes = list(map(lambda x: x**3, nums))
print(cubes)   #output will give:----[1, 8, 27, 64, 125]
===========================================================================================================================
‚ñ∂Ô∏èWhat is the filter() function in Python?
filter() applies a function that returns True or False to each item, and keeps only the items that return True.

program:---
nums=[1,2,3,4,5]
evens=list(filter(lambda x:x%2 ==0,nums))
print(evens)

output will give:----[2,4]
===========================================================================================================================
‚ñ∂Ô∏èWhat is the reduce() function in Python?
reduce() applies a function to combine all items in an iterable into a single result,
like adding or multiplying them together.

program:--
from functools import reduce
nums = [1, 2, 3, 4, 5]
result = reduce(lambda x, y: x + y, nums)
print(result)

output will give:----[15]
=================================================================================================================================================
List Comprehensions in Python 

List comprehensions are a clean and fast way to create lists in Python.
Instead of writing a loop, you can do it all in one line.

Basic Syntax :
new_list = [expression for item in iterable]

Create the same list using list comprehension:

numbers = [x for x in range(1, 6)]
print(numbers)  #Output: [1, 2, 3, 4, 5]

Example 1: Squares of numbers 1 to 5 
squares = [x**2 for x in range(1, 6)]  
print(squares)  # Output: [1, 4, 9, 16, 25]

Example 2: Get even numbers from a list 
nums = [1, 2, 3, 4, 5, 6]  
evens = [x for x in nums if x % 2 == 0]  
print(evens)  # Output: [2, 4, 6]

Ex:----3: nums = [1, 2, 3, 4, 5]  
result = [x*2 for x in nums if x % 2 != 0]  #observe here Takes only odd numbers (x % 2 !== 0),  Multiplies them by 2
print(result) #Output:[2, 6, 10] 

Explanation:---Only odd numbers (1, 3, 5) are selected ‚Üí then multiplied by 2 ‚Üí [2, 6, 10]

List Comprehensions in Python:---------------------------------------------------------

It‚Äôs a concise way to create new lists by applying an expression to each item in an iterable (like a list or range), optionally filtering with conditions.


With Condition: 

even_numbers = [x for x in range(10) if x % 2 == 0]
print(even_numbers)  # Output: [0, 2, 4, 6, 8]


Equivalent Without List Comprehension: 

squares = []
for x in range(5):
    squares.append(x**2) # Output: [0, 1, 4, 9, 16]

Why to use list comprehensions? 

- It‚Äôs more readable and compact
- Runs faster than traditional for loops (in most cases)
- Helps clean up your code
=========================================================================================
‚ñ∂Ô∏èWhat is Exception Handling?
In Python, exception handling means:

*Handling errors that happen while running the program,
*So that the program doesn't crash,
*And you can show a nice message or take safe action when something goes wrong.

‚úÖ Without exception handling ‚Üí Program crashes when error happens.
‚úÖ With exception handling ‚Üí Program continues safely even if error happens.

File_handling_concepts:--Exception Handling is a way to manage errors in your Python program gracefully without crashing the entire program.

When something goes wrong, like dividing by zero or accessing a missing file, Python raises an exception. We use try, 
except, and other blocks to handle those exceptions.

Examples:----

try:
    a='hello'
    b=5
    print(a+b)

except TypeError:
    print('TypeError')
except IndexError:
    print('IndexError')
    raise
else:
    print('hai')
finally:
    print('executed')
===================================================
Important Points:

Situation	                 What happens
No error in try            	else will run
Error in try	            Python jumps to except, else will NOT run
===========================================================
Keyword	Purpose:===

try:======	Try To test a block of code for errors
except:===	Except To handle the error
else:=====	Else Runs if no error in try block
finally:==	Finally Always runs, no matter what (cleanup code)
raise:====	To manually raise an exception
assert:===	Debugging tool to trigger errors if a condition is false
===================================================
Exception	Raised when:======

ZeroDivisionError     	Division by zero
TypeError           	Wrong data type used
NameError	            Variable not defined
IndexError           	Accessing invalid index in list/tuple
ValueError          	Function receives correct type but wrong value
KeyError	            Accessing missing key in dictionary
FileNotFoundError   	File doesn‚Äôt exist
AttributeError	        Attribute not found in object
ImportError	            Import fails
===========================================================
Example 1: With an exception "ZeroDivisionError"

try:
    a = 10
    b = 0
    print(a / b)
except ZeroDivisionError:        #division by zero will get an ZeroDivisionError
    print('ZeroDivisionError')
    raise                        #will give error full information
else:
    print('Anything')
finally:
    print('Always run no matter what' )
O/P:---  Division by zero!
         This will always run.
===========================================================
Example:----2  With an exception "TypeError"

try:
    a = "hello"
    b = 5
    print(a + b)
except TypeError:     # Adding incompatible types (string + int)
    print('TypeError')
    raise             #will give error full information
else:
    print('Anything')
finally:
    print('Always run no matter what' )
O/P:-TypeError
     Always run no matter what
===========================================================
Example:---3    With an exception "Name Error"

try:
    a=5
    b=5
    print(a+c)
except NameError:       # variable not defined thst's why we got nameerror. 
    print('NameError')
    raise               #will give error full information
else:
    print('Anythin')
finally:
    print('Always run no matter what')
O/p:-NameError
     Always run no matter what
=============================================================
Example:---4    With an exception "IndexError"

try:
    a='hello'
    b=5
    print(a[5])
except IndexError:       #Accessing invalid index in list/tuple
    print('IndexError')  #will give error full information
    raise               
else:
    print('Anythin')
finally:
    print('Always run no matter what')
====================================================
Example 5: No exception 

try:
    a = 10
    b = 5
    print(a+b)
    
except NoError:
    print('NoError')
    raise
else:
    print('Anything')
finally:
    print('Always run no matter what' )
O/P:--15
      Anything
      Always run no matter what
================================================================================================
‚ñ∂Ô∏èFile handling:----Defination of File handling in pyhton:---file handling in python is the process of performing operations like creating, opening, reading, writting,appending, and closing files, allows data to be stored and retrived from on the system.

# Writing  the file
with open('myfile.txt', 'w') as f:
    f.write("Hello from Python!\n")
    f.write("This is a second line.")
    f.close()

# Reading the file
with open('myfile.txt', 'r') as f:
    print(f.read())

# Writing (overwrite existing content)
with open('myfile.txt', 'w') as f:
    f.write("New content! Overwriting old content.")

# Appending new content to the file
with open('myfile.txt', 'a') as f:
    f.write("\nThis is the new content added at the end.")

# Reading again after appending
with open('myfile.txt', 'r') as f:
    print(f.read())

===============================================================================================
# Writing to file
f = open("data.txt", "w")
f.write("Hello from Python!\n")
f.write("This is a second line.")
f.close()

# Reading the file
f = open("data.txt", "r")
print(f.read())
f.close()

#Second way to reading the file
f = open("data.txt", "r")
content=f.read()
print(content)
f.close()

**Best Practice: Use with statement
It automatically closes the file.

with open("data.txt", "r") as f:
    content = f.read()
    print(content)


Write to an Existing File

To write to an existing file, you must add a parameter to the open() function:

"a" - Append - will append to the end of the file
"w" - Write - will overwrite any existing content

Example:-------
Open the file "demofile.txt" and append content to the file:

with open("demofile.txt", "a") as f:
  f.write("Now the file has more content!")

#open and read the file after the appending:
with open("demofile.txt") as f:
  print(f.read())
===================================================================
If you want to overwrite existing content, here‚Äôs the correct way:

# Open the file in 'w' mode to overwrite it
with open('my.txt.file', 'w') as f:
    f.write('will overwrite any existing content')

# Open again in 'r' mode to read and check content
with open('my.txt.file', 'r') as f:
    content = f.read()
    print(content)
==================================================================
**Readline:-----
with open('myfile.txt', 'r') as f:
    line1 = f.readline()  # Reads first line
    line2 = f.readline()  # Reads second line

    print(line1)  # Prints first line
    print(line2)  # Prints second line


**Readlines:------
with open('myfile.txt', 'r') as f:
    lines = f.readlines()  # Reads all lines into a list

print(lines)  # Prints the list of lines


**Writelines:------
lines_to_write = ['Hello\n', 'Welcome to Python!\n', 'This is a file.\n']

with open('output.txt', 'w') as f:
    f.writelines(lines_to_write)  # Writes all lines from the list to the file
=====================================================================
‚ñ∂Ô∏èOs module in python:------The os module in Python is used to interact with the operating system.
It lets you create folders, delete files, rename files or directories, work with paths, and run system-level tasks directly from your Python code.

import os
if not os.path.exists('srkcodes1'): #os.path.exists('srkcodes1') checks if the folder is already there.
    os.mkdir('srkcodes1')
for i in range(1,51):
    os.mkdir(os.path.join('srkcodes1', f'Data{i}'))  #Folder path need to give
print("‚úÖ Folders created successfully.")

**
if not os.path.exists(folder_path):
    os.mkdir(folder_path)  # Create the logs folder only if it doesn't exist
================================================================================
Create a single folder :----

import os
folder_name = 'srkcodes1'
if not os.path.exists('srkcodes1'):
    os.mkdir('srkcodes1')
    print("Folder created.")
else:
    print("Folder already exists.")
===========================================
crete a multple folders:---------
import os
os.makedirs('srkcodes1/nrkcodes', exist_ok=True)


 In Simple Words:
os.makedirs() = make many folders at once, safely.
exist_ok=True = don't crash if folders already there.

================================================================================
üßπ To Remove an Empty Folder:
Use os.rmdir() (only works if the folder is empty):

import os
folder_path = 'empty_folder'
if os.path.exists(folder_path):
    os.rmdir(folder_path)
    print("Empty folder removed.")
else:
    print("Folder does not exist.")
============================================================================
üî• To Remove a Folder with files inside it:

import shutil
import os
folder_path='srkcodes1'

if os.path.exists('srkcodes1'):
    shutil.rmtree('srkcodes1')
 print("Folder and all contents removed.")
else:
    print("Folder does not exist.")
===============================================================
Rename the folders :----

import os
os.rename('old_folder', 'new_folder')   # Rename a folder from old name to new name
print("Folder renamed successfully.")
=========================================================
To see the all the files and folders

import os
items=os.listdir('srkcodes1')
for item in items:
    print(item)
=================================================================
NEED TO OBSERVE BELLOW ONE:----
os.path.exists('srkcodes1') checks if the folder already exists.
If it does not exist, os.mkdir('srkcodes1') will create it.

some operations:------
Task:----------	            Function:----

Import                  	        import os
Shows current working directory	    os.getcwd()
Changes current directory	        os.chdir(path)
Lists files/folders in a directory  os.listdir(path)
Creates a new folder                os.mkdir(), os.makedirs()
Delete director&empty foldr         os.rmdir(), os.removedirs()
Renames a file or folder            os.rename(old, new)
Delete file              	        os.remove(filename)
Path operations          	        os.path.*
Environment variables	            os.environ.get("VAR")
Run system command	                os.system("command")
Detect platform	                    os.name
Checks if a file/folder exists      os.path.exists()
=================================================================
‚ñ∂Ô∏èRegular_expressions:----Regular Expression, is a sequence of characters that forms a search pattern.

The findall() Function:--
The findall() function returns a list containing all matches.

Example:--
Print a list of all matches:

import re                        #Return a list containing every occurrence of "ai":
txt = "The rain in Spain"
x = re.findall("ai", txt)
print(x) O/p:--['ai', 'ai']
=================================================================
If no matches are found, an empty list is returned:
Example:---
Return an empty list if no match was found:

import re
txt = "The rain in Spain"
x = re.findall("Portugal", txt)
print(x)

if (x):
  print("Yes, there is at least one match!")
else:
  print("No match") O/P:--[] No match
================================================================
‚ñ∂Ô∏èThe search() Function
The search() function searches the string for a match, and returns a Match object if there is a match.

If there is more than one match, only the first occurrence of the match will be returned:

Example:----
Search for the first white-space character in the string:

import re
txt = "The rain in Spain"
x = re.search("\s", txt)
print("The first white-space character is located in position:", x.start())
=====================================================================================
Example:-----
Search the string to see if it starts with "The" and ends with "Spain":

import re                                 #Check if the string starts with "The" and ends with "Spain": 
txt = "The rain in Spain"
x = re.search("^The.*Spain$", txt)
if x:
  print("YES! We have a match!")
else:
  print("No match")

=====================================================================================
If no matches are found, the value None is returned:

Example
Make a search that returns no match:

import re

txt = "The rain in Spain"
x = re.search("Portugal", txt)
print(x)
=========================================================================================
‚ñ∂Ô∏èThe split() Function
The split() function returns a list where the string has been split at each match:
The split() function returns a list and Split at each white-space character:

Example:-
Split at each white-space character:

import re
txt = "The rain in Spain"
x = re.split("\s", txt)
print(x) O/P:-['The', 'rain', 'in', 'Spain']
=======================================================================
Example:--
Split the string only at the first occurrence:

import re
txt = "The rain in Spain"
x = re.split("\s", txt, 1)
print(x)  O/P:---['The', 'rain in Spain']
=======================================================================
‚ñ∂Ô∏èThe sub() Function
The sub() function replaces the matches with the text of your choice:

Example:----
Replace every white-space character with the number 9:

import re
txt = "The rain in Spain"
x = re.sub("\s", "9", txt)
print(x)  O/P:---The9rain9in9Spain

Example:-Replace the first 2 occurrences:

import re
txt = "The rain in Spain"
x = re.sub("\s", "9", txt, 2)
print(x)  O/P:---The9rain9in Spain
=============================================